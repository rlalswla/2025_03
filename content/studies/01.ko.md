---
id: 1
title: "FE 기술 스택 (라이브러리 & 프레임워크) 선정 이유"
description: "웹 애플리케이션을 위한 적절한 라이브러리와 기술 선택 과정에 대한 이유"
publishedDate: "2025년 3월"
tags:
  [
    "Technology Selection",
    "Bundle Size",
    "Developer Experience",
    "React Ecosystem",
    "Zustand",
    "styled-components",
  ]
url: "https://github.com/softeer5th/Team7-BungeoBbang/wiki/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-(%EA%B8%B0%EC%88%A0)-%EC%84%A0%ED%83%9D-%EC%9D%B4%EC%9C%A0"
locale: "ko"
---

## 기술 스택에 대한 고민과 학습이 필요한 이유

어떤 기술을 사용함에 있어 가장 중요한건 해당 기술에 대한 깊은 이해라고 생각합니다.
얕은 이해를 바탕으로 기술을 사용하게 되면 다양한 문제를 야기하기 쉬워짐은 물론, 문제가 발생했을때, 이를 해결하기가 어렵습니다. 또한 어떤 상황에 어떤 기술을 활용해야 효과적인지를 알기 위해서는 작동원리와 같은 깊은 이해가 필수적이기 때문에, 어떤 기술을 활용하든 깊은 학습을 바탕으로 하기위해 노력했습니다.

기술 선택 프로세스는 다음과 같은 단계로 진행했습니다.

1. 요구사항 분석: 실시간 통신 요구사항, 상태 관리 복잡성, 모바일 호환성 등등 프로젝트의 기능적 및 비기능적 요구사항에 따른 선택.

2. 기술 평가 지표: 다음 기준에 따라 기술을 평가하였습니다:
   - 성능 지표
   - 커뮤니티 지원 및 생태계
   - 학습 곡선 및 팀 친숙도
   - 장기적인 유지보수 고려사항
   - 번들 크기 및 로드 성능
   - 다른 라이브러리와의 통합 능력

## 기술 선택 결정
## React 

아직은 강력한 React 생태계를 넘어설 프레임워크, 라이브러리가 없다고 생각했습니다.
다른 기술이 가지는 강점도 분명 많지만 사용 빈도 측면에서 React 를 확실하게 배워두는게 좋을것이라고 판단했습니다.

## 전역적 상태 관리: Zustand

### context API 를 사용하지 않은 이유

useState 를 사용하여 상태를 관리하고, 리렌더링을 발생시키는 context API 는 다음과 같은 문제점이 있습니다:

1. **성능 이슈**: Context API는 Provider 내부의 값이 변경될 때마다 해당 Context를 구독하는 모든 컴포넌트가 리렌더링됩니다. 이는 상태가 자주 변경되거나 많은 컴포넌트가 구독하는 경우 심각한 성능 저하로 이어질 수 있습니다.

2. **관심사의 분리 어려움**: 단일 Context에 여러 상태와 함수를 포함시키면 불필요한 리렌더링이 발생하며, 여러 Context로 분리하면 코드가 복잡해지고 중첩된 Provider로 인한 "Provider Hell" 문제가 발생합니다.

3. **상태 업데이트 로직 문제**: 복잡한 상태 업데이트 로직을 Context 내에서 관리하면 코드가 복잡해지고 유지보수가 어려워집니다.

4. **테스트 어려움**: Context를 사용하는 컴포넌트는 Provider로 감싸져야 하므로, 단위 테스트 작성 시 추가적인 설정이 필요합니다.

5. **미들웨어 지원 부족**: 상태 변경에 대한 로깅, 디버깅, 지속성과 같은 미들웨어 기능이 기본적으로 제공되지 않습니다.

이에 전역 상태관리 라이브러리를 사용하기로 하였고, 다음과 같은 이유로 Redux 대신 Zustand를 선택했습니다:

- 번들 크기: Zustand는 Redux(react-redux 및 redux-toolkit 포함)의 16KB에 비해 번들에 단 2.2KB만 추가했습니다
- API 단순성: Zustand의 API는 상당히 더 간단하며, 보일러플레이트 파일이 적게 필요합니다
- 학습 곡선: Redux 경험이 없는 팀원들도 Zustand의 직관적인 접근 방식을 빠르게 채택할 수 있었습니다
- TypeScript 통합: Zustand는 더 적은 타입 주석으로 더 나은 TypeScript 지원을 제공했습니다
- 미들웨어 지원: Redux가 더 큰 미들웨어 생태계를 보유하고 있지만, Zustand는 우리가 필요한 핵심 기능(persist, devtools)을 제공했습니다

## 스타일링 솔루션: Styled-Components vs Tailwind CSS

프로젝트 마다 어떤 라이브러리가 적절한지에 대한 고민을 하며, 각각의 라이브러리의 작동원리에 대해 알아보았습니다.

 Styled-Components의 작동 원리
Styled-Components는 CSS-in-JS 라이브러리로, JavaScript 코드 안에서 CSS를 작성할 수 있도록 해줍니다. React 컴포넌트와 스타일을 결합하여 컴포넌트 단위로 스타일을 캡슐화합니다.

CSS를 JavaScript 코드 안에서 작성하며, 스타일은 컴포넌트와 함께 정의됩니다.
스타일은 동적으로 생성된 고유 클래스 이름을 통해 DOM에 적용됩니다.
동적 스타일링:

React의 props를 기반으로 조건부 스타일링을 쉽게 구현할 수 있습니다.
테마를 활용하여 전역 스타일링(예: 다크 모드)을 간단히 적용할 수 있습니다.
범위 지정:

스타일이 컴포넌트 내부에 캡슐화되므로, 다른 컴포넌트와 스타일 충돌이 발생하지 않습니다.

### Tailwind CSS의 작동 원리
Tailwind CSS는 유틸리티 클래스 기반 CSS 프레임워크로, 미리 정의된 CSS 클래스를 사용하여 빠르게 스타일링할 수 있도록 설계되었습니다.

Tailwind는 미리 정의된 CSS 유틸리티 클래스를 제공합니다(예: text-center, bg-blue-500, p-4 등).
HTML 요소에 클래스를 추가하여 스타일을 적용합니다.

스타일이 HTML 클래스 이름에 직접 정의되므로, CSS 파일을 작성할 필요가 없습니다.
CSS-in-JS와 달리 스타일이 JavaScript 코드와 분리되어 있습니다.
커스터마이징:

Tailwind의 설정 파일(tailwind.config.js)을 통해 색상, 간격, 폰트 등을 커스터마이징할 수 있습니다.
필요하지 않은 유틸리티 클래스는 제거하여 번들 크기를 줄일 수 있습니다(PurgeCSS 사용).

### 선택기준
CSS 유틸리티 클래스가 정의된 tailwind 는 반응형, 동적 대응이 큰 장점이라고 생각하여 반응형 웹 프로젝트를 구현할때 주로 사용했으며 
styled-component 같은 경우 프로젝트 규모가 커지거나 ( 가독성이 좋다고 느껴 다수와의 협업시 유리하다고 생각했습니다. ), 적응형 웹 프로젝트를 구현할때 주로 사용하였습니다.

## 서버 상태관리 React Query (tanstack)

클라이언트 상태와 서버 상태는 근본적으로 다른 특성을 가지고 있어 별도의 관리 방식이 필요하다고 판단했습니다. 특히 실시간 채팅과 같은 기능이 많은 프로젝트에서는 서버 상태를 효율적으로 관리하는 것이 매우 중요했습니다.

### 직접 구현한 경험
프로젝트에서 서버 상태관리를 도입해야한다고 판단한뒤, 단순히 React Query 를 사용하기 보다는 직접 서버 상태관리 시스템을 요구에 맞게 구현해서 사용해보는 도전을 통해 작동원리에 대해 깊게 학습할수 있었습니다.
(자세한 내용은 해당 학습 페이지에)

### React Query 선택 이유
서버 상태 특화: React Query는 서버 데이터 관리에 특화된 라이브러리로, 캐싱, 동기화, 업데이트, 에러 처리 등 서버 상태 관리에 필요한 기능을 포괄적으로 제공합니다.

선언적 데이터 페칭: useQuery, useMutation 훅을 통해 데이터 페칭과 상태 관리를 선언적으로 처리할 수 있어, 복잡한 비동기 로직을 간결하게 작성할 수 있었습니다.

자동화된 백그라운드 갱신: 서버 데이터의 최신 상태를 유지하기 위해 staleTime, refetchOnWindowFocus 등의 옵션을 활용하여 자동 갱신을 설정할 수 있었습니다.

강력한 캐싱 메커니즘: 동일한 데이터에 대한 중복 요청을 방지하고, 캐시된 데이터를 효율적으로 활용하여 성능을 최적화할 수 있었습니다.

페이지네이션 및 무한 스크롤 지원: useInfiniteQuery를 통해 채팅 기록과 같은 대량의 데이터를 효율적으로 로드할 수 있었습니다.



## 라우팅: React Router vs TanStack Router

진행한 프로젝트 듫에서 TanStack Router의 유망한 기능에도 불구하고 React Router를 선택했습니다. 이유는 다음과 같습니다.

- 커뮤니티 지원: 훨씬 더 큰 생태계와 커뮤니티 리소스
- 성숙도: 잘 문서화된 패턴으로 프로덕션 환경에서 검증됨
- 학습 곡선: 팀의 기존 친숙도로 개발 시간 단축
- 기능 요구사항: 우리의 라우팅 요구사항은 TanStack Router의 고급 기능을 필요로 하지 않았습니다
- 성능: 벤치마크 테스트 결과 특정 사용 사례에서 최소한의 차이만 보였습니다 (약 5% 차이)

## 빌드 도구: Vite vs Create React App (CRA)

다음과 같은 이유로 대부분의 프로젝트에서 CRA 대신 Vite를 선택했습니다:

- 개발 속도: 상당히 더 빠른 핫 모듈 교체 및 시작 시간
- 현대적 아키텍처: 최적화된 프로덕션 빌드가 있는 ESM 기반 접근 방식
- 유연성: 다양한 플러그인 및 사용자 정의 구성에 대한 더 나은 지원
- 빌드 성능:  테스트에서 CRA보다 60-70% 더 빠른 빌드 속도를 보임
- 활발한 개발: 더 활발한 유지보수와 현대 웹 표준과의 정렬

## 애니메이션: Framer motion

Framer Motion을 프로젝트에 도입하게 된 주요 계기는 AnimatePresence라는 강력한 기능에 있었습니다. 이 기능은 컴포넌트가 DOM에서 제거될 때 애니메이션을 적용할 수 있는 독특한 메커니즘을 제공합니다.

AnimatePresence의 작동 원리
AnimatePresence는 React의 생명주기와 애니메이션을 연결하는 특별한 컴포넌트로, 다음과 같은 과정으로 작동합니다:

컴포넌트 추적: AnimatePresence는 자식 컴포넌트들을 지속적으로 추적하며, 이들이 마운트되거나 언마운트될 때를 감지합니다.

언마운트 지연: 일반적으로 React에서 조건부 렌더링에 의해 컴포넌트가 제거될 때 즉시 DOM에서 사라지지만, AnimatePresence는 이를 지연시켜 애니메이션이 완료될 때까지 컴포넌트를 DOM에 유지합니다.

종료 애니메이션 트리거: 컴포넌트가 제거되어야 할 때, exit 속성에 정의된 애니메이션을 실행하고, 이 애니메이션이 완료된 후에야 실제로 DOM에서 제거합니다.

키 기반 전환: 각 자식 컴포넌트에 고유한 key 속성을 부여하여 React가 컴포넌트의 생성과 제거를 정확하게 추적할 수 있게 합니다.