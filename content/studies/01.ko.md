---
id: 1
title: "FE 기술 스택 (라이브러리 & 프레임워크) 선정 이유"
description: "웹 애플리케이션을 위한 적절한 라이브러리와 기술 선택 과정에 대한 이유"
publishedDate: "2025년 3월"
tags: ["Technology Selection","Bundle Size","Developer Experience","React Ecosystem","Zustand","styled-components"]
url: "https://github.com/softeer5th/Team7-BungeoBbang/wiki/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-(%EA%B8%B0%EC%88%A0)-%EC%84%A0%ED%83%9D-%EC%9D%B4%EC%9C%A0"
locale: "ko"
---


      단순히 많이 사용되는 기술을 이해하지 못한채로 사용하는 상황을 최대한 방지하고자 기술들에 대한 학습들을 진행하였습니다.
      
      기술 선택 프로세스는 다음과 같은 단계로 진행되었습니다:
      
      1. 요구사항 분석: 실시간 통신 요구사항, 상태 관리 복잡성, 모바일 호환성 등등 프로젝트의 기능적 및 비기능적 요구사항에 따른 선택.
      
      2. 기술 평가 지표: 다음 기준에 따라 기술을 평가하였습니다:
         - 성능 지표
         - 커뮤니티 지원 및 생태계
         - 학습 곡선 및 팀 친숙도
         - 장기적인 유지보수 고려사항
         - 번들 크기 및 로드 성능
         - 다른 라이브러리와의 통합 능력
      
      기술 선택 결정:
      
      1. 전역적 상태 관리: Zustand

      프로젝트의 크기가 커짐에 따라 Context API 는 불필요한 리렌더링을 많이 불러오고, 코드의 복잡성을 늘릴것이라고 판단했습니다.
      이에 전역 상태관리 라이브러리를 사용하기로 하였고, 다음과 같은 이유로 Redux 대신 Zustand를 선택했습니다:
      - 번들 크기: Zustand는 Redux(react-redux 및 redux-toolkit 포함)의 16KB에 비해 번들에 단 2.2KB만 추가했습니다
      - API 단순성: Zustand의 API는 상당히 더 간단하며, 보일러플레이트 파일이 적게 필요합니다
      - 학습 곡선: Redux 경험이 없는 팀원들도 Zustand의 직관적인 접근 방식을 빠르게 채택할 수 있었습니다
      - TypeScript 통합: Zustand는 더 적은 타입 주석으로 더 나은 TypeScript 지원을 제공했습니다
      - 미들웨어 지원: Redux가 더 큰 미들웨어 생태계를 보유하고 있지만, Zustand는 우리가 필요한 핵심 기능(persist, devtools)을 제공했습니다
      
      2. 스타일링 솔루션: Styled-Components vs Tailwind CSS
      
      여러 옵션을 평가한 후 Tailwind CSS 대신 styled-components를 선택했습니다:
      - 컴포넌트 캡슐화: React 컴포넌트 아키텍처와 더 잘 일치
      - 동적 스타일링: props와 테마 변수에 기반한 스타일링에 대한 우수한 지원
      - 범위가 지정된 스타일: CSS-in-JS 범위 지정을 통해 스타일 충돌 제거
      - 개발자 경험: 팀이 Tailwind의 유틸리티 클래스보다 CSS 구문에 더 친숙했습니다
      - 번들 크기 고려: 코드 분할을 구현하여 styled-components의 초기 크기가 더 크더라도 영향을 줄였습니다
      
      3. 라우팅: React Router vs TanStack Router
      
      TanStack Router의 유망한 기능에도 불구하고 React Router를 선택했습니다:
      - 커뮤니티 지원: 훨씬 더 큰 생태계와 커뮤니티 리소스
      - 성숙도: 잘 문서화된 패턴으로 프로덕션 환경에서 검증됨
      - 학습 곡선: 팀의 기존 친숙도로 개발 시간 단축
      - 기능 요구사항: 우리의 라우팅 요구사항은 TanStack Router의 고급 기능을 필요로 하지 않았습니다
      - 성능: 벤치마크 테스트 결과 특정 사용 사례에서 최소한의 차이만 보였습니다 (약 5% 차이)
      
      4. 빌드 도구: Vite vs Create React App (CRA)
      
      다음과 같은 이유로 CRA 대신 Vite를 선택했습니다:
      - 개발 속도: 상당히 더 빠른 핫 모듈 교체 및 시작 시간
      - 현대적 아키텍처: 최적화된 프로덕션 빌드가 있는 ESM 기반 접근 방식
      - 유연성: 다양한 플러그인 및 사용자 정의 구성에 대한 더 나은 지원
      - 빌드 성능: 우리 테스트에서 CRA보다 60-70% 더 빠른 빌드
      - 활발한 개발: 더 활발한 유지보수와 현대 웹 표준과의 정렬
      
      이러한 구조화된 접근 방식을 통해 즉각적인 개발 요구사항과 장기적인 유지보수 및 성능 고려사항 사이의 균형을 맞춘 정보에 기반한 결정을 내릴 수 있었습니다.
    

## 핵심 요점

- 기술 평가 프레임워크 개발
- 경쟁 기술 간의 트레이드오프 분석
- 성능 벤치마킹 전략
- 번들 크기 최적화 고려사항
- 개발자 경험 우선순위 지정
- 생태계 및 커뮤니티 지원 평가


## 코드 예제

```typescript
No code Example
```


## 적용

이러한 구조화된 기술 선택 접근 방식은 ON:U 프로젝트에 적용되어 균형 잡힌 기술 스택을 구축할 수 있었습니다. Redux 대신 Zustand를 선택한 것은 번들 크기를 약 14KB 줄이고 더 간단한 API 덕분에 개발 속도를 크게 향상시켰습니다. styled-components 선택은 컴포넌트 기반 아키텍처와 완벽하게 일치하여 테마와 사용자 선호도에 따른 동적 스타일링을 가능하게 했습니다. 빌드 도구로 Vite를 선택한 것은 개발 중 60% 더 빠른 리빌드와 배포 시간을 평균 4분에서 1.5분으로 줄이는 등 개발자 경험을 향상시켰습니다. 이러한 의도적인 기술 선택은 전체적으로 개발 속도와 최종 사용자 경험을 모두 개선하여, 우리 애플리케이션은 Lighthouse 벤치마크에서 성능 점수가 76에서 89로 향상되었습니다.

